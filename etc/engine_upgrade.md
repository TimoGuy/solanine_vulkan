- [x] Editor inputs
    - F1    Toggle play/edit mode (level-level if in level editor | world-level if in world editor | game-level if otherwise)
    - F2    Toggle editor UI
    - F3    Toggle rendering mode (shaded | simple | wireframe | unlit)
    - F4    
    - F5
    - F6
    - F7
    - F8
    - F9
    - F10
    - F11   Toggle fullscreen
- [x] Input system that's action based not render thread based.
    - [x] Add runtime check for whether the correct inputs are being used on the correct threads.
- [x] RenderObjects can either have their own simulation position that gets set or they get tied to a physics object with some offset.
    - [x] Tie a simulation transform id (one vec3 one quat) to the render object, and this gets returned from creating something like a character or voxelfield.
    - [f] For physics objects that have multiple ties with an offset, don't let multiple objects tie themselves to the one physics object, rather put the subsequent objects as siblings so that multiple lerps and nlerps don't have to happen for the one physics object.
- [x] When all the physics objects' new transforms are calculated, insert them into a "next" queue.
- [x] At the end of the delay, at the beginning of the physics loop, lock the physics transform data and swap pointers between the "prev", "current", and "next" so that only pointer swaps have to happen instead of actual data copying inside of the lock.
- [x] At the beginning of every frame right before uploading the positions of the renderobjects' transforms an object interpolation step is put.
    - [x] This, as well as where the simulation position pointers are getting swapped are where multithreaded locks are placed.
    > This results in a massive speedup since the render thread can run almost lock free! (250 -> 600 fps (saving 2.333333ms))
- [ ] Material maker
    - [ ] Main Engine Changes
        - [f] Change `VulkanEngine` to `VulkanRenderer`.
            - [ ] Set up main engine. It manages the window, selects the renderer/starts the render engine, starts the simulation engine, then polls for input and keeps the input state up to date. Upon shutting down it takes care of shutting down the render engine and simulation engine.
        - [ ] Separate things out into editor modes
            - [x] Level Editor (everything created up to this point with a loaded in scene)
            - [x] Texture Editor
            - [ ] Material Editor (what we're gonna create. Just no objects except for the `MaterialViewer` object type to render the textures and a bunch of imgui stuff)
    - [x] Texture cooker
        - [x] Textures to mid gen textures.
        - [ ] Run all mid gen then run texture cooking.
            - [ ] Create simple hotswap dependency tree.
            - [ ] Collect jobs when checking hot swappiness.
            - [ ] Order all jobs with a few dependency relationship entries.
                > Seomthing like `".halfstep" -> ".hrecipe"`, then `".hrecipe" -> ".hderriere"`, and `".vert" -> ".humba"`, and `".frag" -> ".humba"`
                > Maybe there could be something like each file type gathering other resources to reload bc one resource reloaded. Idk.
                > But hey, instead of saving a resource list and checking just those resources, maybe something like just recursively checking all the files in the "res" folder would be good, then processing on the new ones and saving their previous modified time. Then any that are missing, create a delete resource job for them.
        - [x] Textures from pool and recipe into ktx format.
            > I think that the texture viewer needs to happen after the new material system gets implemented. We can cook some textures into ktx and write the texture cooker, but the viewer feels EXTREMELY full of friction. I believe that once the material system gets written, the viewer should be really easy to implement. Just assign a material to a render object and just keep changing "texture test material"'s albedo with the texture the creator is looking at.
        - [f] Texture viewer
            - [ ] Select filenames from the `/Textures` folder and subfolders. Import textures as a type of internal texture.
            - [ ] Can delete imported textures.
            - [ ] Texture viewer once it's imported
                - 2D
                    - [ ] Quad
                    - [x] Sphere
                - 3D/2Darray
                    - [ ] Quad-slices
                        - [ ] Slice spread attribute (so that can see each individual slice. Use z axis for 3d textures for slices)
                - Cubemap
                    - [ ] Sphere-cubemap
                    - [ ] Skybox
    - [ ] New material system.
        - [ ] Load in pipelines from .humba files.
            - [ ] Use SPIRV-Reflect to generate descriptor set layouts and pipeline layouts.
            - [ ] Connect globaldescriptor, objectdescriptor, etc. to the parts where the name matches from reflection.
        - [ ] Load in materials from .hderriere files.
            - [ ] Create list of which unique textures to use and insert into descriptor set.
            - [ ] Insert all material params into material collection.
        - [ ] Migrate to material system.
            - [ ] Connect material to render object's palette. When loading in the model, it will also return a palette, and the programmer can insert that palette or insert a loaded palette swap file into the render object.
                - [f] Load palette swap file.
            - [ ] Don't load textures with vkgltf. (bandaid)
            - [ ] Turn off the "pbrmaterial" material.
    - [ ] Material viewer
        - [x] Orbit camera view
        - [ ] Sphere material inspector.
            - [x] Draw sphere with as the subject for the orbit view.

