#version 460

layout (local_size_x = 128) in;

// Indirect Draw Commands.
struct IndirectDrawCommandsData
{
    uint indexCount;
    uint instanceCount;
    uint firstIndex;
    int  vertexOffset;
    uint firstInstance;
};

layout(set = 0, binding = 0) buffer IndirectDrawCommandsBuffer
{
	IndirectDrawCommandsData commands[];
} drawCommands;


// Indirect Draw Command Offsets.
struct IndirectDrawCommandOffsetsData
{
	uint batchFirstIndex;
	uint countIndex;
	uint pad0;
	uint pad1;
};

layout(std140, set = 0, binding = 1) readonly buffer IndirectDrawCommandOffsetsBuffer
{
	IndirectDrawCommandOffsetsData offsets[];
} drawCommandOffsets;


// Indirect Draw Command Counts.
layout(set = 0, binding = 2) buffer IndirectDrawCommandCountsBuffer
{
	uint counts[];
} drawCommandCounts;


// All Object Matrices
struct ObjectData
{
	mat4 modelMatrix;
	vec4 boundingSphere;
};

layout(std140, set = 1, binding = 0) readonly buffer ObjectBuffer
{
	ObjectData objects[];
} objectBuffer;


// Instance ID Pointers
struct InstancePointer
{
	uint objectID;
	uint materialID;
	uint animatorNodeID;  // @TODO: take out! This will be used by the compute skinning process.
	uint voxelFieldLightingGridID;
};

layout(std140, set = 2, binding = 0) readonly buffer InstancePtrBuffer
{
	InstancePointer pointers[];
} instancePtrBuffer;


// Params.
layout(push_constant) uniform Params {
    uint numInstances;
} params;


bool isVisible(uint objectID)
{
    // @TODO: add visibility check.
    return true;
}


void main()
{
    uint gID = gl_GlobalInvocationID.x;
    if (gID < params.numInstances)
    {
        if (isVisible(instancePtrBuffer.pointers[gID].objectID))
        {
            uint countIdx = drawCommandOffsets.offsets[gID].countIndex;
            uint batchOffset = atomicAdd(drawCommandCounts.counts[countIdx], 1);

            // Copy draw command data.
            uint copyTo = drawCommandOffsets.offsets[gID].batchFirstIndex + batchOffset;
            drawCommands.commands[copyTo] = drawCommands.commands[gID];
        }
    }
}
