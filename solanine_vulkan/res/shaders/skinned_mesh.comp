#version 460

layout (local_size_x = 256) in;

// All skinned meshes.
struct InputMeshData
{
	vec3 pos;
    uint animatorNodeID;  // @NOTE: insert offset here so that 16 byte padding can be complete and normal doesn't get garbage values.  -Timo 2023/12/16
    vec3 normal;
    uint baseInstanceID;  // Here too.
    vec2 UV0;
    vec2 UV1;
    vec4 joint0;
    vec4 weight0;
    vec4 color0;
};

layout(std140, set = 0, binding = 0) readonly buffer MeshInputBuffer
{
    uint numVertices;
    uint pad0;
    uint pad1;
    uint pad2;
	InputMeshData indices[];
} inputData;

// Output skinned meshes.
struct OutputMeshData
{
	vec3 pos;
    uint instanceIDOffset;  // @NOTE: insert offset here so that 16 byte padding can be complete and normal doesn't get garbage values.  -Timo 2023/12/16
    vec3 normal;
	uint pad0;  // Here too.
    vec2 UV0;
    vec2 UV1;
    vec4 color0;
};

layout(std140, set = 0, binding = 1) buffer OutputBuffer
{
    OutputMeshData indices[];
} outputData;

// Skeletal Animation/Skinning.
#define MAX_NUM_JOINTS 128
struct SkeletonAnimationNode
{
	mat4 matrix;
	mat4 jointMatrix[MAX_NUM_JOINTS];
	float jointCount;
};

layout (std140, set = 1, binding = 0) readonly buffer SkeletonAnimationNodeCollection
{
	SkeletonAnimationNode nodes[];
} nodeCollection;


void main()
{
    uint gID = gl_GlobalInvocationID.x;
    if (gID < inputData.numVertices)
    {
        uint nodeID = inputData.indices[gID].animatorNodeID;
        mat4 nodeMatrix = nodeCollection.nodes[nodeID].matrix;
        vec4 joint = inputData.indices[gID].joint0;  // @NOTE: this vec4 copy may be non-performant.
        vec4 weight = inputData.indices[gID].weight0;  // @NOTE: this vec4 copy may be non-performant.

        mat4 skinMat =
            nodeCollection.nodes[nodeID].jointMatrix[int(joint.x)] * weight.x +
            nodeCollection.nodes[nodeID].jointMatrix[int(joint.y)] * weight.y +
            nodeCollection.nodes[nodeID].jointMatrix[int(joint.z)] * weight.z +
            nodeCollection.nodes[nodeID].jointMatrix[int(joint.w)] * weight.w;

        // Spit out the data!
        // outputData.indices[gID].pos = inputData.indices[gID].pos;  // @DEBUG
        outputData.indices[gID].pos = vec3(nodeMatrix * skinMat * vec4(inputData.indices[gID].pos, 1.0));
        // outputData.indices[gID].normal = inputData.indices[gID].normal;  // @DEBUG
        outputData.indices[gID].normal = normalize(transpose(inverse(mat3(nodeMatrix * skinMat))) * inputData.indices[gID].normal);
        outputData.indices[gID].UV0 = inputData.indices[gID].UV0;
        outputData.indices[gID].UV1 = inputData.indices[gID].UV1;
        outputData.indices[gID].color0 = inputData.indices[gID].color0;
        outputData.indices[gID].instanceIDOffset = inputData.indices[gID].baseInstanceID;
    }
}
